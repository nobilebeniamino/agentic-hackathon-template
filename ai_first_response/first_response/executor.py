"""
Emergency Response Executor
Implements the execution component of the agentic architecture
"""
import google.generativeai as genai
from django.conf import settings
from typing import List, Dict, Any
import json
import logging
import requests
from datetime import datetime
from .disaster_feeds import get_disaster_feed
from .metrics import agentic_metrics

logger = logging.getLogger(__name__)

# Configure Gemini
genai.configure(api_key=settings.GEMINI_API_KEY)

class EmergencyExecutor:
    """
    Agentic Executor that carries out planned emergency response actions
    """
    
    def __init__(self):
        self.model = genai.GenerativeModel('gemini-1.5-flash')
        self.available_tools = [
            'disaster_feed_check',
            'weather_check',
            'resource_lookup',
            'contact_services',
            'generate_instructions'
        ]
    
    def execute_plan(self, plan: Dict, context: Dict) -> Dict:
        """
        Execute the emergency response plan using available tools
        
        Args:
            plan: Plan generated by EmergencyPlanner
            context: Emergency context (message, location, etc.)
            
        Returns:
            Execution results with actions taken and outcomes
        """
        
        execution_log = {
            'start_time': datetime.now().isoformat(),
            'executed_actions': [],
            'failed_actions': [],
            'tool_calls': [],
            'final_status': 'in_progress'
        }
        
        # Execute immediate actions first
        for action in plan.get('immediate_actions', []):
            result = self._execute_action(action, context)
            execution_log['executed_actions'].append(result)
            
            # Record action execution metrics
            success = result.get('status') == 'completed'
            agentic_metrics.record_action_execution(action, success)
        
        # Execute follow-up actions
        for action in plan.get('followup_actions', []):
            result = self._execute_action(action, context)
            execution_log['executed_actions'].append(result)
            
            # Record action execution metrics
            success = result.get('status') == 'completed'
            agentic_metrics.record_action_execution(action, success)
        
        execution_log['end_time'] = datetime.now().isoformat()
        execution_log['final_status'] = 'completed'
        
        return execution_log
    
    def _execute_action(self, action: Dict, context: Dict) -> Dict:
        """Execute a single action using appropriate tools"""
        
        action_type = self._classify_action(action.get('action', ''))
        
        execution_result = {
            'action': action.get('action'),
            'priority': action.get('priority'),
            'start_time': datetime.now().isoformat(),
            'tool_used': None,
            'result': None,
            'status': 'pending'
        }
        
        try:
            if action_type == 'disaster_feed_check':
                result = self._check_disaster_feed(context)
                execution_result['tool_used'] = 'disaster_feed'
                execution_result['result'] = result
                
            elif action_type == 'weather_check':
                result = self._check_weather_conditions(context)
                execution_result['tool_used'] = 'weather_api'
                execution_result['result'] = result
                
            elif action_type == 'resource_lookup':
                result = self._lookup_resources(context)
                execution_result['tool_used'] = 'resource_database'
                execution_result['result'] = result
                
            elif action_type == 'generate_instructions':
                result = self._generate_specific_instructions(action, context)
                execution_result['tool_used'] = 'gemini_ai'
                execution_result['result'] = result
                
            else:
                # Default execution with Gemini reasoning
                result = self._execute_with_reasoning(action, context)
                execution_result['tool_used'] = 'gemini_reasoning'
                execution_result['result'] = result
            
            execution_result['status'] = 'completed'
            
        except Exception as e:
            execution_result['status'] = 'failed'
            execution_result['error'] = str(e)
            logger.error(f"Action execution failed: {str(e)}")
        
        execution_result['end_time'] = datetime.now().isoformat()
        return execution_result
    
    def _classify_action(self, action_text: str) -> str:
        """Classify action to determine which tool to use"""
        action_lower = action_text.lower()
        
        if any(word in action_lower for word in ['disaster', 'earthquake', 'flood', 'fire']):
            return 'disaster_feed_check'
        elif any(word in action_lower for word in ['weather', 'storm', 'rain', 'wind']):
            return 'weather_check'
        elif any(word in action_lower for word in ['resource', 'hospital', 'shelter', 'supplies']):
            return 'resource_lookup'
        elif any(word in action_lower for word in ['instruct', 'guide', 'tell', 'explain']):
            return 'generate_instructions'
        else:
            return 'general_reasoning'
    
    def _check_disaster_feed(self, context: Dict) -> Dict:
        """Use disaster feed tool to check for ongoing disasters"""
        try:
            lat = context.get('location', {}).get('lat', 0)
            lon = context.get('location', {}).get('lon', 0)
            
            # Use existing disaster feed function
            feed_data = get_disaster_feed(lat, lon)
            
            return {
                'tool': 'disaster_feed',
                'data': feed_data,
                'summary': f"Found {len(feed_data.split(';')) if feed_data else 0} active disasters in area"
            }
        except Exception as e:
            return {'error': str(e), 'tool': 'disaster_feed'}
    
    def _check_weather_conditions(self, context: Dict) -> Dict:
        """Simulate weather check (placeholder for real weather API)"""
        return {
            'tool': 'weather_check',
            'conditions': 'current weather conditions simulated',
            'summary': 'Weather data would be fetched from real API in production'
        }
    
    def _lookup_resources(self, context: Dict) -> Dict:
        """Lookup nearby emergency resources"""
        return {
            'tool': 'resource_lookup',
            'resources': [
                {'type': 'hospital', 'distance': '2.3 km', 'name': 'Emergency Hospital'},
                {'type': 'fire_station', 'distance': '1.1 km', 'name': 'Fire Station 12'},
                {'type': 'police', 'distance': '0.8 km', 'name': 'Police Station'}
            ],
            'summary': 'Found nearby emergency resources'
        }
    
    def _generate_specific_instructions(self, action: Dict, context: Dict) -> Dict:
        """Generate specific instructions using Gemini AI"""
        
        instruction_prompt = f"""
You are an Emergency Response Instructor. Generate specific, actionable instructions for this action:

ACTION: {action.get('action')}
PRIORITY: {action.get('priority')}
CONTEXT: {context.get('message', '')}
LOCATION: lat={context.get('location', {}).get('lat', 0)}, lon={context.get('location', {}).get('lon', 0)}

Provide detailed, step-by-step instructions in JSON format:
{{
    "steps": [
        {{"step": 1, "instruction": "...", "duration": "...", "safety_note": "..."}},
        {{"step": 2, "instruction": "...", "duration": "...", "safety_note": "..."}}
    ],
    "safety_warnings": ["...", "..."],
    "success_indicators": ["...", "..."]
}}
"""
        
        try:
            response = self.model.generate_content(
                instruction_prompt,
                generation_config=genai.types.GenerationConfig(
                    temperature=0.2,
                    candidate_count=1,
                )
            )
            
            raw_text = response.text
            if "```json" in raw_text:
                start = raw_text.find("```json") + 7
                end = raw_text.find("```", start)
                if end != -1:
                    raw_text = raw_text[start:end].strip()
            
            instructions = json.loads(raw_text)
            return {
                'tool': 'gemini_instructions',
                'instructions': instructions,
                'summary': f"Generated {len(instructions.get('steps', []))} instruction steps"
            }
            
        except Exception as e:
            return {
                'tool': 'gemini_instructions',
                'error': str(e),
                'fallback': 'Follow standard emergency procedures'
            }
    
    def _execute_with_reasoning(self, action: Dict, context: Dict) -> Dict:
        """Execute action with Gemini reasoning"""
        
        reasoning_prompt = f"""
You are an Emergency Response Executor. Analyze and execute this action:

ACTION: {action.get('action')}
PRIORITY: {action.get('priority')}
ESTIMATED_TIME: {action.get('estimated_time')}
RESPONSIBLE: {action.get('responsible')}

CONTEXT:
- Message: {context.get('message', '')}
- Category: {context.get('category', '')}
- Severity: {context.get('severity', '')}
- Location: lat={context.get('location', {}).get('lat', 0)}, lon={context.get('location', {}).get('lon', 0)}

Provide reasoning and execution outcome in JSON:
{{
    "reasoning": "Why this action is important and how to execute it",
    "execution_steps": ["step1", "step2", "step3"],
    "expected_outcome": "What should happen after execution",
    "monitoring_required": true/false,
    "next_actions": ["follow-up action if needed"]
}}
"""
        
        try:
            response = self.model.generate_content(
                reasoning_prompt,
                generation_config=genai.types.GenerationConfig(
                    temperature=0.3,
                    candidate_count=1,
                )
            )
            
            raw_text = response.text
            if "```json" in raw_text:
                start = raw_text.find("```json") + 7
                end = raw_text.find("```", start)
                if end != -1:
                    raw_text = raw_text[start:end].strip()
            
            reasoning = json.loads(raw_text)
            return {
                'tool': 'gemini_reasoning',
                'reasoning': reasoning,
                'summary': 'Action analyzed and executed with AI reasoning'
            }
            
        except Exception as e:
            return {
                'tool': 'gemini_reasoning',
                'error': str(e),
                'fallback': 'Action noted for manual execution'
            }
